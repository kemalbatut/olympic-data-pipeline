## Function Documentation: permutations_all_lengths() ##
File: utils.py
Author: Yigit Dalkilic

## Overview ##
Generates all possible permutations of a list at all possible lengths, including partial permutations. This is a recursive function generated by ChatGPT (as noted in the code comments).

## Purpose ##
This helper function creates all permutations of list elements, including permutations of subsets. It's used by get_name_permutations() to handle athletes with multiple last names (e.g., "Jean Pierre Martin" could match "Jean Pierre", "Jean Martin", "Pierre Martin", etc.). This enables flexible name matching for duplicate detection.

## Parameters ##

lst (list): List of elements to permute

## Returns ##

list: List of all permutations at all lengths (as lists)

## Algorithm (Pseudocode) ##
permutations_all_lengths(lst)
1. def permute(cur, remaining, result):
2.     if cur:
3.         result.append(cur[:])
4.     for i in range(len(remaining)):
5.         permute(cur + [remaining[i]], remaining[:i] + remaining[i+1:], result)
6. result = []
7. permute([], lst, result)
8. return result

## How It Works ##
Inner Recursive Function: permute(cur, remaining, result)

Check current permutation - If cur is not empty, add it to results
Base case - When remaining is empty, recursion stops naturally
Recursive case - For each element in remaining:

Add element to current permutation
Remove element from remaining
Recursively call permute with updated lists

## Outer Function ##

Initialize result list - Create empty list to collect all permutations
Start recursion - Call permute with empty current, full remaining
Return results - Return complete list of all permutations

## Variables ##

n = number of elements in the input list


## Time Complexity Analysis ##
Operation Count
The function generates all permutations of all subset sizes:

Size 1: n permutations (P(n,1) = n)
Size 2: n(n-1) permutations (P(n,2) = n!/(n-2)!)
Size 3: n(n-1)(n-2) permutations
Size n: n! permutations

Total permutations = n + n(n-1) + n(n-1)(n-2) + ... + n!
This grows faster than n! but is bounded by n! × n
T(n) Calculation
T(n) = O(n × n!)
For practical sizes (n ≤ 4 for name parts):

n=2: ~4 permutations
n=3: ~16 permutations
n=4: ~64 permutations

## Big-O Analysis ##
T(n) = n × n!
O(n!)
The function has factorial time complexity, but for small inputs (athlete names with 2-4 parts), this is acceptable.

## Example Usage ##
python# Simple list with 2 elements
result1 = permutations_all_lengths([1, 2])
Returns: [[1], [2], [1, 2], [2, 1]]

List with 3 elements
result2 = permutations_all_lengths(['A', 'B', 'C'])
Returns: 
[
    ['A'], ['B'], ['C'],                    # Size 1
    ['A','B'], ['A','C'], ['B','A'], 
    ['B','C'], ['C','A'], ['C','B'],        # Size 2
    ['A','B','C'], ['A','C','B'],
    ['B','A','C'], ['B','C','A'],
    ['C','A','B'], ['C','B','A']            # Size 3
]

## Name parts example ##
result3 = permutations_all_lengths(['Pierre', 'Martin'])
Returns:
[
     ['Pierre'],
    ['Martin'],
   ['Pierre', 'Martin'],
    ['Martin', 'Pierre']
]

## Real-World Name Example ##
python# Athlete name: "Jean Pierre Martin"
Last names: ['Pierre', 'Martin']

perms = permutations_all_lengths(['Pierre', 'Martin'])
Returns:
[
     ['Pierre'],           → "Jean Pierre"
     ['Martin'],           → "Jean Martin"
    ['Pierre', 'Martin'], → "Jean Pierre Martin"
     ['Martin', 'Pierre']  → "Jean Martin Pierre"
]

-Used to check all possible name variations in Olympic database

## Key Features ##

All subset sizes - Includes permutations from size 1 to size n
No repetition - Each permutation appears once
Recursive approach - Clean, functional-style implementation
AI-generated - Code generated by ChatGPT (noted in comments)
Helper function - Not called directly, used by get_name_permutations()


## Why This Matters ##
Problem: Athletes with multiple last names may appear differently in datasets

"Jean-Pierre Martin" in one dataset
"Jean Pierre" in another
"Jean Martin Pierre" in a third

Solution: Generate all possible name combinations to check against Olympic database

## Performance Considerations ##
For typical athlete names:

2 last name parts: 4 permutations ✓ Fast
3 last name parts: 16 permutations ✓ Acceptable
4 last name parts: 64 permutations ✓ Still manageable

Warning: Don't use with large lists (n > 5) - exponential growth!

## END OF DOCUMENTATION ##